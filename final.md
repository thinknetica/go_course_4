# Итоговый проект
## Сервис хранения коротких гиперссылок (URL Shortener)

Пример: https://www.shorturl.at/

### Название
Наше приложение будет называться lynks.

### Возможности сервиса
Сервис должен предоставлять следующие взможности пользователю:
1. Принимать на вход длинную ссылку, формировать на её основе короткую на базе собственного домена, сохранять в БД пару ссылок и возвращать пользователю короткую ссылку.
2. При переходе пользователя по короткой ссылке на домен нашего сервиса, программа должна запросить из БД длинную ссылку на основе короткой и выполнить перенаправление пользователя на оригинальную страницу.

### Пример
Допустим, что наш сервис работает на домене *lynks.org*. Тогда, если пользователь выполняет HTTP-запрос:
```
curl --location 'https://lynks.org' \
--header 'Content-Type: application/json' \
--data '{
    "destination": "https://github.com/thinknetica/go_course_4"
}'
```

То сервис может вернуть примерно такой ответ:
```
{
    "shortUrl": "https://lynks.org/qz6d7",
    "destination": "https://github.com/thinknetica/go_course_4"
}
```
Далее, если пользователь перейдёт по ссылке `https://lynks.org/qz6d7` то сервис выполнит HTTP Redirect (https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections) на страницу `https://github.com/thinknetica/go_course_4`.

### Состав компонентов и схема
Сервис должен состоять из следующих компонентов:  
1. Микросервис коротких гиперссылок. Этот микросервис должен предоставлять методы API для формирования короткой ссылки и выполнять переход по короткой ссылке на оригинальную страницу.
2. БД микросервиса коротких ссылок. Это должна быть СУБД PostgreSQL с одной таблицей для хранения пар гиперссылок. Для таблицы нужно создать индекс для эффективного поиска длинной гиперссылки по короткой.
3. Микросервис кэширования. Этот микросервис должен ускорить поиск гиперссылок за счёт хранения недавно созданных пар ссылок в быстрой in-memory БД. Микросервис кэширования должен предоставлять метод API, который бы принимал и сохранял в БД пару гиперссылок. Также должен быть метод API для получения длинной ссылки на основе короткой.
4. БД микросервиса кэширования. Следует использовать СУБД Redis для хранения и быстрого доступа к парам гиперссылок.

### Структура приложения
Каждый микросервис должен иметь структуру каталогов как принято в курсе (см. занятие по архитектуре приложения - https://github.com/thinknetica/go_course_4/tree/master/17-system-design/app)  
Можно разместить оба микросервиса в одном общем каталоге внутри модуля всего курса. Создавать отдельный репозиторий не требуется.

### Дополнительные требования
- Микросервисы должны предоставлять HTTP API.
- Для получния данных должен использоваться метод GET, для записи - POST.
- Тело запросов и ответо должно быть в формате JSON.
- Базы данных следует развернуть в виде контейнеров. 
- Микросервисы также следует запускать в контейнере. Нужно добавить Dockerfile для каждого сервиса.
- Нужно сделать итоговый Docker Compose файл, который сможет запустить всё приложение целиком.
- Каждый микросервис должен считать метрики запросов в формате Prometheus: количество запросов к каждому методу API (CounterVec) и время обработки запроса (HistogramVec).
- Микросервисы должны использовать структурированное логирование с помощью пакета https://github.com/rs/zerolog. Следует писать в консоль (stdout) каждое обращение к методам API и все возникающие в работе ошибки.
- В БД кэширования должна хранить пары гиперссылок не более 24 часов (следует указать время экспирации).
